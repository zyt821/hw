<?php
// async_processor.php - 异步处理脚本
session_start();

// 获取任务ID
$task_id = $argv[1] ?? '';
if (empty($task_id)) {
    die("缺少任务ID");
}

$status_file = "task_status_" . $task_id . ".json";
$cancel_file = "cancel_" . $task_id . ".flag";

// 引入你现有的数据库连接和类
require_once 'your_database_functions.php'; // 你现有的数据库函数

// 更新状态的函数
function update_status($task_id, $status, $progress, $message) {
    $status_file = "task_status_" . $task_id . ".json";
    $data = [
        'status' => $status,
        'progress' => $progress,
        'message' => $message,
        'updated_at' => time()
    ];
    file_put_contents($status_file, json_encode($data));
}

// 检查是否被取消
function is_cancelled($task_id) {
    $cancel_file = "cancel_" . $task_id . ".flag";
    return file_exists($cancel_file);
}

// 清理函数
function cleanup($task_id) {
    $status_file = "task_status_" . $task_id . ".json";
    $cancel_file = "cancel_" . $task_id . ".flag";
    
    if (file_exists($status_file)) unlink($status_file);
    if (file_exists($cancel_file)) unlink($cancel_file);
}

try {
    update_status($task_id, 'processing', 0, '开始处理文件...');

    // 从会话或临时存储获取文件信息
    $upload_info_file = "upload_info_" . $task_id . ".json";
    if (!file_exists($upload_info_file)) {
        throw new Exception("找不到上传文件信息");
    }
    
    $upload_info = json_decode(file_get_contents($upload_info_file), true);
    
    // 检查取消状态
    if (is_cancelled($task_id)) {
        update_status($task_id, 'cancelled', 0, '处理已被用户取消');
        cleanup($task_id);
        exit(0);
    }

    update_status($task_id, 'processing', 10, '读取DCE文件...');
    
    // 处理DCE文件
    $dceData = [];
    if (($handle = fopen($upload_info['dce_file'], "r")) !== FALSE) {
        $headers = fgetcsv($handle);
        $row_count = 0;
        while (($row = fgetcsv($handle)) !== FALSE) {
            // 每100行检查一次取消状态
            if ($row_count % 100 == 0 && is_cancelled($task_id)) {
                fclose($handle);
                update_status($task_id, 'cancelled', 15, '处理已被用户取消');
                cleanup($task_id);
                exit(0);
            }
            
            if (count($row) == count($headers)) {
                $dceData[] = array_combine($headers, $row);
            }
            $row_count++;
        }
        fclose($handle);
    }

    update_status($task_id, 'processing', 25, '存储DCE数据到数据库...');
    
    // 分批存储DCE数据
    $dce_batches = array_chunk($dceData, 500); // 每批500条
    $batch_num = 0;
    foreach ($dce_batches as $batch) {
        if (is_cancelled($task_id)) {
            update_status($task_id, 'cancelled', 30, '处理已被用户取消');
            cleanup($task_id);
            exit(0);
        }
        
        $dceFieldMapping = [
            'hostname' => 'hostname',
            'useruid' => 'useruid', 
            'sn_number' => 'serial',
            'livedate' => 'livedate',
            'userwhen' => 'userwhen'
        ];
        storeCsvDataToDatabase($batch, 'dce_data', $task_id, $dceFieldMapping);
        
        $batch_num++;
        $progress = 25 + (15 * $batch_num / count($dce_batches));
        update_status($task_id, 'processing', $progress, "存储DCE数据批次 $batch_num/" . count($dce_batches));
    }

    // 检查取消
    if (is_cancelled($task_id)) {
        update_status($task_id, 'cancelled', 40, '处理已被用户取消');
        cleanup($task_id);
        exit(0);
    }

    update_status($task_id, 'processing', 40, '读取ARGOS文件...');
    
    // 处理ARGOS文件 (类似DCE处理)
    $argosData = [];
    if (($handle = fopen($upload_info['argos_file'], "r")) !== FALSE) {
        $headers = fgetcsv($handle);
        $row_count = 0;
        while (($row = fgetcsv($handle)) !== FALSE) {
            if ($row_count % 100 == 0 && is_cancelled($task_id)) {
                fclose($handle);
                update_status($task_id, 'cancelled', 45, '处理已被用户取消');
                cleanup($task_id);
                exit(0);
            }
            
            if (count($row) == count($headers)) {
                $argosData[] = array_combine($headers, $row);
            }
            $row_count++;
        }
        fclose($handle);
    }

    update_status($task_id, 'processing', 55, '存储ARGOS数据到数据库...');
    
    // 分批存储ARGOS数据
    $argos_batches = array_chunk($argosData, 500);
    $batch_num = 0;
    foreach ($argos_batches as $batch) {
        if (is_cancelled($task_id)) {
            update_status($task_id, 'cancelled', 60, '处理已被用户取消');
            cleanup($task_id);
            exit(0);
        }
        
        $argosFieldMapping = [
            'hostname' => 'Hostname',
            'owner' => 'Owner',
            'serial_number' => 'Serial #',
            'state' => 'State'
        ];
        storeCsvDataToDatabase($batch, 'argos_data', $task_id, $argosFieldMapping);
        
        $batch_num++;
        $progress = 55 + (15 * $batch_num / count($argos_batches));
        update_status($task_id, 'processing', $progress, "存储ARGOS数据批次 $batch_num/" . count($argos_batches));
    }

    // 处理SN文件 (类似处理)
    if (is_cancelled($task_id)) {
        update_status($task_id, 'cancelled', 70, '处理已被用户取消');
        cleanup($task_id);
        exit(0);
    }

    update_status($task_id, 'processing', 70, '读取SN文件...');
    
    $snData = [];
    if (($handle = fopen($upload_info['sn_file'], "r")) !== FALSE) {
        $headers = fgetcsv($handle);
        $row_count = 0;
        while (($row = fgetcsv($handle)) !== FALSE) {
            if ($row_count % 100 == 0 && is_cancelled($task_id)) {
                fclose($handle);
                update_status($task_id, 'cancelled', 75, '处理已被用户取消');
                cleanup($task_id);
                exit(0);
            }
            
            if (count($row) == count($headers)) {
                $snData[] = array_combine($headers, $row);
            }
            $row_count++;
        }
        fclose($handle);
    }

    update_status($task_id, 'processing', 80, '存储SN数据...');
    
    $sn_batches = array_chunk($snData, 500);
    $batch_num = 0;
    foreach ($sn_batches as $batch) {
        if (is_cancelled($task_id)) {
            update_status($task_id, 'cancelled', 85, '处理已被用户取消');
            cleanup($task_id);
            exit(0);
        }
        
        $snFieldMapping = [
            'serial_number' => 'Serial number',
            'State' => 'State', 
            'pending_collection' => 'Pending collection [Hardware]'
        ];
        storeCsvDataToDatabase($batch, 'sn_data', $task_id, $snFieldMapping);
        
        $batch_num++;
        $progress = 80 + (10 * $batch_num / count($sn_batches));
        update_status($task_id, 'processing', $progress, "存储SN数据批次 $batch_num/" . count($sn_batches));
    }

    // 开始比较分析
    if (is_cancelled($task_id)) {
        update_status($task_id, 'cancelled', 90, '处理已被用户取消');
        cleanup($task_id);
        exit(0);
    }

    update_status($task_id, 'processing', 90, '开始数据比较分析...');
    
    $comparator = new ExcelComparisonTool();
    $comparator->setSessionId($task_id);
    
    // 加载数据
    $comparator->importDceFile();
    $comparator->importArgosFile(); 
    $comparator->importSnFile();
    
    // 清理数据
    $comparator->cleanAllData();
    
    // 执行比较 - 使用较小的批次大小以便更频繁检查取消状态
    update_status($task_id, 'processing', 95, '执行数据比较...');
    
    // 修改compareData方法以支持取消检查
    $results = $comparator->compareDataWithCancelCheck($task_id);
    
    if ($results === false) {
        // 比较过程中被取消
        update_status($task_id, 'cancelled', 95, '数据比较已被用户取消');
        cleanup($task_id);
        exit(0);
    }
    
    // 保存结果
    update_status($task_id, 'processing', 98, '保存比较结果...');
    
    saveResultsToDatabase($results);
    $temp_session_id = storeComparisonResults($results);
    
    // 保存最终会话ID
    file_put_contents("final_session_" . $task_id . ".txt", $temp_session_id);
    
    // 完成
    update_status($task_id, 'completed', 100, '处理完成！');
    
    // 清理临时文件
    unlink($upload_info_file);
    
} catch (Exception $e) {
    update_status($task_id, 'error', 0, '处理出错: ' . $e->getMessage());
    cleanup($task_id);
}
?>
