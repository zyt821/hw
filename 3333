# 基于数据库的异步处理 + 中断功能实施指南

## 优势分析

由于你已经将文件存储改为数据库模式，这个方案有以下优势：

- **更安全**：无需文件系统权限，所有状态存储在数据库中
- **更可靠**：数据库事务保证数据一致性
- **更易维护**：统一的数据存储，便于监控和管理
- **支持集群**：多台服务器可以共享同一个数据库状态

## 实施步骤

### 1. 创建任务状态表

在你的数据库中执行以下SQL：

```sql
CREATE TABLE IF NOT EXISTS task_status (
    id INT AUTO_INCREMENT PRIMARY KEY,
    task_id VARCHAR(50) UNIQUE NOT NULL,
    status ENUM('pending', 'processing', 'completed', 'cancelled', 'error') DEFAULT 'pending',
    progress INT DEFAULT 0,
    message TEXT,
    session_id VARCHAR(50),
    final_session_id VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_task_id (task_id),
    INDEX idx_status (status)
);
```

### 2. 添加数据库函数

将第一个artifact中的所有函数添加到你的现有数据库函数文件中：

- `createTaskStatusTable()`
- `updateTaskStatus()`
- `getTaskStatus()`
- `createTask()`
- `cancelTask()`
- `isTaskCancelled()`

### 3. 创建新的异步处理器类

将 `DatabaseAsyncProcessor` 和 `ExcelComparisonToolWithDatabaseCancel` 类添加到你的主脚本中。

### 4. 创建独立的支持文件

从第二个artifact创建以下文件：

- `cancel_task.php`
- `get_task_progress.php`
- `get_final_session.php`
- `async_processor_db.php`

### 5. 修改你的现有脚本

在 `test11.php` 中：

1. 添加 `handleFileUploadAsyncDatabase()` 函数
1. 添加 `showProcessingPageDatabase()` 函数
1. 添加 `cleanupOldTasks()` 函数
1. 修改主执行逻辑

## 工作流程

### 文件上传流程

```
用户上传文件 → 立即保存到数据库 → 创建任务记录 → 启动后台处理 → 重定向到处理页面
```

### 异步处理流程

```
后台脚本启动 → 从数据库读取数据 → 分批处理 → 每批检查取消状态 → 更新进度 → 保存结果
```

### 取消流程

```
用户点击取消 → 更新任务状态为cancelled → 后台脚本检测到状态变化 → 立即停止并清理数据
```

## 关键特性

### 立即响应中断

```php
// 在每个处理批次前检查
if (isTaskCancelled($task_id)) {
    $this->cleanup(); // 清理数据
    return false;     // 停止处理
}
```

### 实时进度更新

```php
// 每个阶段都更新进度
updateTaskStatus($task_id, 'processing', 60, '加载SN数据...');
```

### 自动资源清理

```php
// 取消时清理相关数据
foreach ($tables as $table) {
    $stmt = $conn->prepare("DELETE FROM $table WHERE session_id = ?");
    $stmt->execute([$session_id]);
}
```

## 数据库表说明

### task_status 表字段

- `task_id`: 唯一任务标识符
- `status`: 任务状态（pending/processing/completed/cancelled/error）
- `progress`: 进度百分比（0-100）
- `message`: 当前状态描述
- `session_id`: 关联的会话ID（用于数据关联）
- `final_session_id`: 完成后的最终会话ID（用于结果展示）

### 状态流转

```
pending → processing → completed
                   ↘ cancelled
                   ↘ error
```

## 配置建议

### PHP配置优化

```ini
; 增加内存限制
memory_limit = 512M

; 增加最大执行时间（对CLI模式）
max_execution_time = 300

; 启用垃圾回收
zend.enable_gc = On
```

### 数据库优化

```sql
-- 为经常查询的字段添加索引
ALTER TABLE task_status ADD INDEX idx_session_id (session_id);
ALTER TABLE task_status ADD INDEX idx_updated_at (updated_at);

-- 定期清理旧数据
DELETE FROM task_status WHERE created_at < DATE_SUB(NOW(), INTERVAL 7 DAY);
```

## 监控和维护

### 清理脚本

创建定时任务每小时清理旧数据：

```bash
# 添加到crontab
0 * * * * /usr/bin/php /path/to/your/project/cleanup_old_tasks.php
```

### 错误监控

```php
// 在每个关键函数中添加错误日志
error_log("Task $task_id failed: " . $e->getMessage());
```

### 性能监控

```sql
-- 查看正在处理的任务
SELECT * FROM task_status WHERE status = 'processing';

-- 查看任务处理统计
SELECT status, COUNT(*) as count 
FROM task_status 
WHERE created_at > DATE_SUB(NOW(), INTERVAL 1 DAY)
GROUP BY status;
```

## 故障排除

### 常见问题

**任务卡在processing状态**

```sql
-- 查找超时任务
SELECT * FROM task_status 
WHERE status = 'processing' 
AND updated_at < DATE_SUB(NOW(), INTERVAL 10 MINUTE);

-- 手动重置超时任务
UPDATE task_status 
SET status = 'error', message = '处理超时'
WHERE status = 'processing' 
AND updated_at < DATE_SUB(NOW(), INTERVAL 10 MINUTE);
```

**取消功能不响应**

```php
// 检查取消检查点是否足够频繁
if ($batch_counter % 10 == 0) { // 每10批检查一次可能太少
    if (isTaskCancelled($task_id)) {
        return false;
    }
}
```

**内存使用过高**

```php
// 减少批次大小
$results = $comparator->compareDataWithDatabaseCancelCheck($task_id, 100); // 从500改为100

// 强制垃圾回收
if (function_exists('gc_collect_cycles')) {
    gc_collect_cycles();
}
```

## 测试建议

### 功能测试清单

- [ ] 文件上传后任务创建成功
- [ ] 进度显示正确更新
- [ ] 取消功能立即响应
- [ ] 错误处理正确显示
- [ ] 完成后正确跳转
- [ ] 数据清理功能正常

### 压力测试

```php
// 测试大量并发任务
for ($i = 0; $i < 10; $i++) {
    $task_id = uniqid('test_');
    createTask($task_id, $session_id);
    // 启动后台处理
}
```

这个基于数据库的解决方案为你提供了一个完整、可靠的异步处理系统，能够在FPM-FCGI环境下实现有效的用户中断功能。
