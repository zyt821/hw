<?php
class ExcelComparisonTool {
    private $dceData = [];
    private $argosData = [];
    private $snData = [];
    private $comparisonResults = [];
    private $sessionId = '';

    public function setSessionId($sessionId) {
        $this->sessionId = $sessionId;
        return $this;
    }

    public function setComparisonResults(array $results) {
        $this->comparisonResults = $results;
        return $this;
    }

    public function importDceFile($sessionId = null) {
        $sessionId = $sessionId ?: $this->sessionId;
        if (!$sessionId) {
            throw new Exception("Session ID is required");
        }
        $this->dceData = loadCsvDataFromDatabase('dce_data', $sessionId);
        return $this->dceData;
    }

    public function importArgosFile($sessionId = null) {
        $sessionId = $sessionId ?: $this->sessionId;
        if (!$sessionId) {
            throw new Exception("Session ID is required");
        }
        $this->argosData = loadCsvDataFromDatabase('argos_data', $sessionId);
        return $this->argosData;
    }

    public function importSnFile($sessionId = null) {
        $sessionId = $sessionId ?: $this->sessionId;
        if (!$sessionId) {
            throw new Exception("Session ID is required");
        }
        $this->snData = loadCsvDataFromDatabase('sn_data', $sessionId);
        return $this->snData;
    }

    // NEW: Compare data with cancellation support
    public function compareDataWithCancellation($jobId, $progressCallback = null, int $batchSize = 1000) {
        $comparisonResults = [];

        // Helper function to check cancellation
        $checkCancel = function() use ($jobId) {
            try {
                $conn = new mysqli('localhost', 'root', '', 'compliance_db');
                $stmt = $conn->prepare("SELECT cancel_requested FROM job_cancel_flags WHERE job_id = ?");
                $stmt->bind_param("s", $jobId);
                $stmt->execute();
                $stmt->bind_result($cancelRequested);
                $stmt->fetch();
                $stmt->close();
                $conn->close();
                return (bool)$cancelRequested;
            } catch (Exception $e) {
                return false;
            }
        };

        // Step 1: Create indexed lookup arrays
        $argosMap = [];
        foreach ($this->argosData as $argosRow) {
            $serialKey = strtolower($argosRow['serial#']);
            if (!isset($argosMap[$serialKey])) {
                $argosMap[$serialKey] = [];
            }
            $argosMap[$serialKey][] = $argosRow;
        }

        $snMap = [];
        foreach ($this->snData as $snRow) {
            $serialKey = strtolower($snRow['Serial number']);
            if (!isset($snMap[$serialKey])) {
                $snMap[$serialKey] = [];
            }
            $snMap[$serialKey][] = $snRow;
        }

        // Step 2: Process DCE data in batches with cancellation checks
        $totalDce = count($this->dceData);
        for ($i = 0; $i < $totalDce; $i += $batchSize) {
            // Check for cancellation
            if ($checkCancel()) {
                return false;
            }

            $batch = array_slice($this->dceData, $i, $batchSize);

            foreach ($batch as $dceRow) {
                $dceSerial = strtolower($dceRow['serial'] ?? '');
                $matchedArgosRows = $argosMap[$dceSerial] ?? [];

                if (empty($matchedArgosRows)) {
                    $comparisonResults[] = [
                        'hostname' => $dceRow['hostname'] ?? 'N/A',
                        'dce_useruid' => $dceRow['useruid'] ?? 'N/A',
                        'dce_sn' => $dceRow['serial'] ?? 'N/A',
                        'argos_owner' => 'N/A',
                        'argos_serial' => 'N/A',
                        'sn_serial' => 'N/A',
                        'dce_livedate' => $dceRow['livedate'] ?? 'N/A',
                        'dce_userwhen' => $dceRow['userwhen'] ?? 'N/A',
                        'argos_state' => 'N/A',
                        'sn_state' => 'N/A',
                        'sn_pending_collection' => 'N/A',
                        'dce_status' => 'N/A',
                        'compliance_status' => 'non-compliant',
                        'compliance_reason' => 'No matching ARGOS entry'
                    ];
                    continue;
                }

                foreach ($matchedArgosRows as $argosRow) {
                    $argosSerial = strtolower($argosRow['serial#'] ?? '');
                    $matchedSnRows = $snMap[$argosSerial] ?? [];

                    if (empty($matchedSnRows)) {
                        $comparisonResults[] = [
                            'hostname' => $dceRow['hostname'] ?? 'N/A',
                            'dce_useruid' => $dceRow['useruid'] ?? 'N/A',
                            'dce_sn' => $dceRow['serial'] ?? 'N/A',
                            'argos_owner' => $argosRow['owner'] ?? 'N/A',
                            'argos_serial' => $argosRow['serial#'] ?? 'N/A',
                            'sn_serial' => 'N/A',
                            'dce_livedate' => $dceRow['livedate'] ?? 'N/A',
                            'dce_userwhen' => $dceRow['userwhen'] ?? 'N/A',
                            'argos_state' => $argosRow['state'] ?? 'N/A',
                            'sn_state' => 'N/A',
                            'sn_pending_collection' => 'N/A',
                            'dce_status' => $this->checkDceStatus($dceRow, $argosRow),
                            'compliance_status' => 'non-compliant',
                            'compliance_reason' => 'No matching SN entry'
                        ];
                        continue;
                    }

                    foreach ($matchedSnRows as $snRow) {
                        $dceStatus = $this->checkDceStatus($dceRow, $argosRow);
                        $complianceResult = $this->checkCompliance($dceStatus, $argosRow, $snRow);

                        $comparisonResults[] = [
                            'hostname' => $dceRow['hostname'] ?? 'N/A',
                            'dce_useruid' => $dceRow['useruid'] ?? 'N/A',
                            'dce_sn' => $dceRow['serial'] ?? 'N/A',
                            'argos_owner' => $argosRow['owner'] ?? 'N/A',
                            'argos_serial' => $argosRow['serial#'] ?? 'N/A',
                            'sn_serial' => $snRow['Serial number'] ?? 'N/A',
                            'dce_livedate' => $dceRow['livedate'] ?? 'N/A',
                            'dce_userwhen' => $dceRow['userwhen'] ?? 'N/A',
                            'argos_state' => $argosRow['state'] ?? 'N/A',
                            'sn_state' => $snRow['State'] ?? 'N/A',
                            'sn_pending_collection' => $snRow['Pending collection [Hardware]'] ?? 'N/A',
                            'dce_status' => $dceStatus,
                            'compliance_status' => $complianceResult['status'],
                            'compliance_reason' => $complianceResult['reason']
                        ];
                    }
                }
            }

            // Report progress
            if ($progressCallback) {
                $progress = ($i + $batchSize) / $totalDce;
                $progressCallback(min($progress * 0.33, 0.33)); // First 33%
            }

            unset($batch);
            if (function_exists('gc_collect_cycles')) {
                gc_collect_cycles();
            }
        }

        // Step 3: Process ARGOS records not in DCE
        $totalArgos = count($this->argosData);
        for ($i = 0; $i < $totalArgos; $i += $batchSize) {
            if ($checkCancel()) {
                return false;
            }

            $batch = array_slice($this->argosData, $i, $batchSize);

            foreach ($batch as $argosRow) {
                $argosSerial = strtolower($argosRow['serial#'] ?? '');
                $found = false;
                foreach ($this->dceData as $dceRow) {
                    if (strcasecmp($dceRow['serial'] ?? '', $argosRow['serial#'] ?? '') === 0) {
                        $found = true;
                        break;
                    }
                }

                if (!$found) {
                    $matchedSnRows = $snMap[$argosSerial] ?? [];
                    if (empty($matchedSnRows)) {
                        $comparisonResults[] = [
                            'hostname' => $argosRow['hostname'] ?? 'N/A',
                            'dce_useruid' => 'N/A',
                            'dce_sn' => 'N/A',
                            'argos_owner' => $argosRow['owner'] ?? 'N/A',
                            'argos_serial' => $argosRow['serial#'] ?? 'N/A',
                            'sn_serial' => 'N/A',
                            'dce_livedate' => 'N/A',
                            'dce_userwhen' => 'N/A',
                            'argos_state' => $argosRow['state'] ?? 'N/A',
                            'sn_state' => 'N/A',
                            'sn_pending_collection' => 'N/A',
                            'dce_status' => 'N/A',
                            'compliance_status' => 'non-compliant',
                            'compliance_reason' => 'In ARGOS but not in DCE or SN'
                        ];
                    } else {
                        foreach ($matchedSnRows as $snRow) {
                            $complianceResult = $this->checkCompliance('dce_disabled', $argosRow, $snRow);
                            $comparisonResults[] = [
                                'hostname' => $argosRow['hostname'] ?? 'N/A',
                                'dce_useruid' => 'N/A',
                                'dce_sn' => 'N/A',
                                'argos_owner' => $argosRow['owner'] ?? 'N/A',
                                'argos_serial' => $argosRow['serial#'] ?? 'N/A',
                                'sn_serial' => $snRow['Serial number'] ?? 'N/A',
                                'dce_livedate' => 'N/A',
                                'dce_userwhen' => 'N/A',
                                'argos_state' => $argosRow['state'] ?? 'N/A',
                                'sn_state' => $snRow['State'] ?? 'N/A',
                                'sn_pending_collection' => $snRow['Pending collection [Hardware]'] ?? 'N/A',
                                'dce_status' => 'dce_disabled',
                                'compliance_status' => $complianceResult['status'],
                                'compliance_reason' => $complianceResult['reason']
                            ];
                        }
                    }
                }
            }

            if ($progressCallback) {
                $progress = ($i + $batchSize) / $totalArgos;
                $progressCallback(0.33 + min($progress * 0.33, 0.33)); // 33-66%
            }

            unset($batch);
            if (function_exists('gc_collect_cycles')) {
                gc_collect_cycles();
            }
        }

        // Step 4: Process SN records not in DCE or ARGOS
        $totalSn = count($this->snData);
        for ($i = 0; $i < $totalSn; $i += $batchSize) {
            if ($checkCancel()) {
                return false;
            }

            $batch = array_slice($this->snData, $i, $batchSize);

            foreach ($batch as $snRow) {
                $foundInDce = false;
                foreach ($this->dceData as $dceRow) {
                    if (strcasecmp($dceRow['serial'] ?? '', $snRow['Serial number'] ?? '') === 0) {
                        $foundInDce = true;
                        break;
                    }
                }

                $foundInArgos = false;
                if (!$foundInDce) {
                    foreach ($this->argosData as $argosRow) {
                        if (strcasecmp($argosRow['serial#'] ?? '', $snRow['Serial number'] ?? '') === 0) {
                            $foundInArgos = true;
                            break;
                        }
                    }
                }

                if (!$foundInDce && !$foundInArgos) {
                    $comparisonResults[] = [
                        'hostname' => 'N/A',
                        'dce_useruid' => 'N/A',
                        'dce_sn' => 'N/A',
                        'argos_owner' => 'N/A',
                        'argos_serial' => 'N/A',
                        'sn_serial' => $snRow['Serial number'] ?? 'N/A',
                        'dce_livedate' => 'N/A',
                        'dce_userwhen' => 'N/A',
                        'argos_state' => 'N/A',
                        'sn_state' => $snRow['State'] ?? 'N/A',
                        'sn_pending_collection' => $snRow['Pending collection [Hardware]'] ?? 'N/A',
                        'dce_status' => 'N/A',
                        'compliance_status' => 'non-compliant',
                        'compliance_reason' => 'In SN but not in DCE or ARGOS'
                    ];
                }
            }

            if ($progressCallback) {
                $progress = ($i + $batchSize) / $totalSn;
                $progressCallback(0.66 + min($progress * 0.34, 0.34)); // 66-100%
            }

            unset($batch);
            if (function_exists('gc_collect_cycles')) {
                gc_collect_cycles();
            }
        }

        $this->comparisonResults = $comparisonResults;
        return $comparisonResults;
    }

    // Original compareData method (kept for compatibility)
    public function compareData(int $batchSize = 1000): array {
        // This now just calls the new method without cancellation support
        return $this->compareDataWithCancellation('', null, $batchSize);
    }

    private function checkDceStatus(array $dceRow, array $argosRow): string {
        $ownerMatch = strcasecmp($dceRow['useruid'], $argosRow['owner']) === 0;
        return ($ownerMatch) ? 'dce_active' : 'dce_disabled';
    }

    private function checkCompliance(string $dceStatus, array $argosRow, array $snRow): array {
        $argosState = strtolower($argosRow['state']);
        $snState = strtolower($snRow['State']);
        $snPendingCollection = strtolower($snRow['Pending collection [Hardware]']);

        $status = 'non-compliant';
        $reason = '';

        if ($dceStatus === 'dce_disabled') {
            switch ($argosState) {
                case 'state_unassigned':
                    if ($snState === 'in stock') {
                        $status = 'compliant';
                        $reason = 'DCE disabled, Argos = state_unassigned, SN in stock';
                    } else {
                        $reason = "DCE disabled, Argos = state_unassigned, but SN state is not 'in stock'";
                    }
                    break;
                case 'state_pending_signoff':
                case 'state_signed_off':
                    $reason = "DCE disabled with ARGOS = $argosState is non-compliant";
                    break;
                case 'state_pending_collection':
                    if ($snPendingCollection === 'true') {
                        $status = 'compliant';
                        $reason = 'DCE disabled, Argos = state_pending_collection, SN pending collection is true';
                    } else {
                        $reason = 'DCE disabled, Argos = state_pending_collection, but SN pending collection is not true';
                    }
                    break;
                case 'state_retired':
                    if ($snState === 'retired' || $snState === 'missing') {
                        $status = 'compliant';
                        $reason = "DCE disabled, Argos = state_retired, SN state is $snState";
                    } else {
                        $reason = "DCE disabled, Argos = state_retired, but SN state is not 'retired' or 'missing'";
                    }
                    break;
                default:
                    $reason = "Unknown ARGOS state: $argosState";
                    break;
            }
        } else if ($dceStatus === 'dce_active') {
            switch ($argosState) {
                case 'state_unassigned':
                    if ($snState === 'in stock') {
                        $status = 'compliant';
                        $reason = 'DCE not disabled, Argos = state_unassigned, SN in stock';
                    } else {
                        $reason = "DCE not disabled, Argos = state_unassigned, but SN state is not 'in stock'";
                    }
                    break;
                case 'state_pending_signoff':
                case 'state_signed_off':
                    if ($snState === 'in use') {
                        $status = 'compliant';
                        $reason = "DCE not disabled, Argos = $argosState, SN in use";
                    } else {
                        $reason = "DCE not disabled, Argos = $argosState, but SN state is not 'in use'";
                    }
                    break;
                case 'state_pending_collection':
                    if ($snPendingCollection === 'true') {
                        $status = 'compliant';
                        $reason = 'DCE not disabled, Argos = state_pending_collection, SN pending collection is true';
                    } else {
                        $reason = 'DCE not disabled, Argos = state_pending_collection, but SN pending collection is not true';
                    }
                    break;
                case 'state_retired':
                    $reason = 'DCE not disabled but Argos = state_retired';
                    break;
                default:
                    $reason = "Unknown ARGOS state: $argosState";
                    break;
            }
        } else {
            $reason = "Unknown DCE status: $dceStatus";
        }

        return [
            'status' => $status,
            'reason' => $reason
        ];
    }

    public function exportNonCompliantResults() {
        $nonCompliantResults = array_filter($this->comparisonResults, function($result) {
            return $result['compliance_status'] === 'non-compliant';
        });

        $headers = [
            'Hostname', 'DCE UserUID', 'ARGOS Owner', 'DCE SN#', 'ARGOS Serial#',
            'SN Serial Number', 'DCE Livedate', 'DCE Userwhen', 'ARGOS State',
            'SN State', 'SN Pending Collection', 'DCE Status', 'Compliance Status',
            'Compliance Reason'
        ];

        $exportDir = __DIR__ . '/exports/';
        if (!is_dir($exportDir)) {
            mkdir($exportDir, 0777, true);
        }

        $filename = $exportDir . 'non_compliant_results_' . date('YmdHis') . '.csv';
        $file = fopen($filename, 'w');
        fputcsv($file, $headers);

        foreach ($nonCompliantResults as $result) {
            $row = [];
            foreach ($headers as $header) {
                $key = $this->getKeyFromHeader($header);
                $row[] = $result[$key] ?? 'N/A';
            }
            fputcsv($file, $row);
        }

        fclose($file);
        return $filename;
    }

    private function getKeyFromHeader($header) {
        $mapping = [
            'Hostname' => 'hostname',
            'DCE UserUID' => 'dce_useruid',
            'ARGOS Owner' => 'argos_owner',
            'DCE SN#' => 'dce_sn',
            'ARGOS Serial#' => 'argos_serial',
            'SN Serial Number'=> 'sn_serial',
            'DCE Livedate' => 'dce_livedate',
            'DCE Userwhen' => 'dce_userwhen',
            'ARGOS State' => 'argos_state',
            'SN State' => 'sn_state',
            'SN Pending Collection' => 'sn_pending_collection',
            'DCE Status' => 'dce_status',
            'Compliance Status' => 'compliance_status',
            'Compliance Reason' => 'compliance_reason'
        ];
        return $mapping[$header] ?? strtolower(str_replace(' ', '_', $header));
    }

    public function cleanDceData() {
        if (empty($this->dceData)) {
            return;
        }
        $this->dceData = array_filter($this->dceData, function ($row) {
            if (empty($row['serial']) || $row['serial'] === 'N/A' || $row['serial'] === '') {
                return false;
            }
            $nonEmptyValues = array_filter($row, function ($value) {
                return !empty($value) && $value !== 'N/A' && $value !== '';
            });
            return count($nonEmptyValues) > 0;
        });
        $this->dceData = array_values($this->dceData);
        return $this->dceData;
    }

    public function cleanArgosData() {
        if (empty($this->argosData)) {
            return;
        }
        $this->argosData = array_filter($this->argosData, function ($row) {
            if (empty($row['serial#']) || $row['serial#'] === 'N/A' || $row['serial#'] === '') {
                return false;
            }
            $nonEmptyValues = array_filter($row, function ($value) {
                return !empty($value) && $value !== 'N/A' && $value !== '';
            });
            return count($nonEmptyValues) > 0;
        });
        $this->argosData = array_values($this->argosData);
        return $this->argosData;
    }

    public function cleanSnData() {
        if (empty($this->snData)) {
            return;
        }
        $this->snData = array_filter($this->snData, function ($row) {
            if (empty($row['Serial number']) || $row['Serial number'] === 'N/A' || $row['Serial number'] === '') {
                return false;
            }
            $nonEmptyValues = array_filter($row, function ($value) {
                return !empty($value) && $value !== 'N/A' && $value !== '';
            });
            return count($nonEmptyValues) > 0;
        });
        $this->snData = array_values($this->snData);
        return $this->snData;
    }

    public function cleanAllData() {
        $this->cleanDceData();
        $this->cleanArgosData();
        $this->cleanSnData();
        return $this;
    }
}
?>
